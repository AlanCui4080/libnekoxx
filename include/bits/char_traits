/*
 *	libnekoxx
 *	By MIT License.
 *	Copyright (c) 2023 Ziyao.
 */

#ifndef __NEKOXX_BITS_CHAR_TRAITS_INC__
#define __NEKOXX_BITS_CHAR_TRAITS_INC__

#include<cstddef>
#include<cstdio>
#include<cstring>
#include<cwchar>

namespace __libnekoxx {

template <class T>
constexpr T eof_helper_v = 0;
template <> 
constexpr wint_t eof_helper_v<wint_t> = WEOF;
template <> 
constexpr int eof_helper_v<int> = EOF;

template <class _Char, class _Int, class _Pos, class _Off, class _State>
class char_traits {
    public:
	using char_type		= _Char;
	using int_type		= _Int;
	using off_type		= _Off;
	using pos_type		= _Pos;
	using state_type	= _State;

	static inline constexpr void assign(_Char &r, const char &a) noexcept
	{
		r = a;
	}
	static constexpr char_type *assign(_Char *p, std::size_t c, _Char a)
	{
		for (int i = 0; i < c; i++)
			p[i] = a;
	}

	static constexpr bool eq(_Char a, _Char b) noexcept
	{
		return a == b;
	}

	static constexpr bool lt(_Char a, _Char b) noexcept
	{
		return a < b;
	}

	static _Char *move(_Char *dest, const _Char *src, std::size_t count)
		noexcept
	{
		return static_cast<_Char*>(memmove(dest, src, sizeof(_Char) * count));
	}

	static _Char *copy(_Char *dest, const _Char *src, std::size_t count)
		noexcept
	{
		return static_cast<_Char*>(memcpy(dest, src, sizeof(_Char) * count));
	}

	static int compare(const _Char *a, const _Char *b, std::size_t count)
		noexcept
	{
		while (count--) {
			if (*a != *b)
				return *a - *b;
			a++;
			b++;
		}
		return 0;
	}

	static std::size_t length(_Char *s) noexcept
	{
		std::size_t c = 0;
		while(*s)
			s++, c++;
		return c;
	}

	static const _Char *find(const _Char *s, std::size_t count,
				 const _Char &ch) noexcept
	{
		while (count--) {
			if (*s == ch)
				return s;
			s++;
		}
		return nullptr;
	}

	static _Char to_char_type(_Int c) noexcept
	{
		return static_cast<_Char>(c);
	}

	static _Int to_int_type(_Char c) noexcept
	{
		return static_cast<_Int>(c);
	}

	static bool eq_int_type(_Int c1, _Int c2) noexcept
	{
		return c1 == c2;
	}

	static _Int eof() noexcept
	{
		return __libnekoxx::eof_helper_v<_Char>;
	}

	static _Int not_eof(_Int e) noexcept
	{
		return eq_int_type(e, eof()) ? e : static_cast<_Int>(0);
	}
};
};	// namespace std;

#endif
